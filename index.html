<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Reaction Timer — Systems-Focused Implementation</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg: #0F172A;
      --surface: #111827;
      --text-primary: #E5E7EB;
      --text-secondary: #9CA3AF;

      --idle: #38BDF8;
      --go: #22C55E;
      --error: #EF4444;
      --result: #FACC15;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--text-primary);
      font-family: Inter, system-ui, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    main {
      width: 100%;
      max-width: 720px;
      padding: 24px;
      background: var(--surface);
      border-radius: 12px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }

    header h1 {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 600;
    }

    #instructions {
      color: var(--text-secondary);
      font-size: 0.95rem;
    }

    #result {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.5rem;
      min-height: 2rem;
    }

    #canvas-container {
      width: 100%;
      height: 260px;
      background: #020617;
      border-radius: 8px;
      overflow: hidden;
    }

    footer {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    canvas#history-chart {
      background: #020617;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <main>
    <header>
      <h1>Reaction Timer</h1>
    </header>

    <section id="instructions">
      Click or press <strong>Space</strong> when the shape turns green.
    </section>

    <div id="canvas-container" aria-hidden="true"></div>

    <div id="result" aria-live="polite"></div>

    <footer>
      Single-round reaction test. Early inputs are explicitly detected.
    </footer>

    <canvas id="history-chart" width="680" height="200" aria-label="Reaction time history"></canvas>
  </main>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js';

    /* ================================
       STATE MACHINE
       ================================ */
    const STATE = Object.freeze({
      IDLE: 'IDLE',
      WAITING: 'WAITING',
      STIMULUS: 'STIMULUS',
      RESULT: 'RESULT',
      ERROR: 'ERROR'
    });

    let currentState = STATE.IDLE;

    /* ================================
       TIMING
       ================================ */
    const MIN_DELAY = 1500;
    const MAX_DELAY = 3000;

    let stimulusTimeoutId = null;
    let stimulusTimestamp = 0;

    /* ================================
       REACTION HISTORY
       ================================ */
    const MAX_HISTORY = 30;
    const reactionHistory = [];

    /* ================================
       DOM
       ================================ */
    const instructionsEl = document.getElementById('instructions');
    const resultEl = document.getElementById('result');
    const canvasContainer = document.getElementById('canvas-container');
    const chartCanvas = document.getElementById('history-chart');
    const chartCtx = chartCanvas.getContext('2d');

    /* ================================
       THREE.JS SETUP
       ================================ */
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
      50,
      canvasContainer.clientWidth / canvasContainer.clientHeight,
      0.1,
      100
    );
    camera.position.z = 4;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    canvasContainer.appendChild(renderer.domElement);

    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshStandardMaterial({ color: '#38BDF8' });
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(2, 2, 5);
    scene.add(light);

    /* ================================
       DYNAMIC ROTATION
       ================================ */
    let rotationVelocity = new THREE.Vector3(0, 0, 0);

    function randomizeRotationVelocity() {
      rotationVelocity.set(
        (Math.random() - 0.5) * 0.04,
        (Math.random() - 0.5) * 0.04,
        (Math.random() - 0.5) * 0.04
      );
    }

    /* ================================
       STATE → VISUALS
       ================================ */
    function applyVisualState(state) {
      switch (state) {
        case STATE.IDLE:
          cube.material.color.set('#38BDF8');
          cube.rotation.set(0, 0, 0);
          rotationVelocity.set(0, 0, 0);
          break;
        case STATE.WAITING:
          cube.material.color.set('#9CA3AF');
          randomizeRotationVelocity();
          break;
        case STATE.STIMULUS:
          cube.material.color.set('#22C55E');
          rotationVelocity.multiplyScalar(2);
          break;
        case STATE.ERROR:
          cube.material.color.set('#EF4444');
          rotationVelocity.multiplyScalar(-1);
          break;
        case STATE.RESULT:
          cube.material.color.set('#FACC15');
          rotationVelocity.set(0.01, 0.02, 0);
          break;
      }
    }

    /* ================================
       STATE TRANSITIONS
       ================================ */
    function transitionTo(state) {
      currentState = state;
      applyVisualState(state);
    }

    function startRound() {
      clearTimeout(stimulusTimeoutId);
      resultEl.textContent = '';
      instructionsEl.textContent = 'Wait for green…';
      transitionTo(STATE.WAITING);

      const delay = MIN_DELAY + Math.random() * (MAX_DELAY - MIN_DELAY);
      stimulusTimeoutId = setTimeout(() => {
        stimulusTimestamp = performance.now();
        instructionsEl.textContent = 'GO!';
        transitionTo(STATE.STIMULUS);
      }, delay);
    }

    function handleReaction() {
      if (currentState !== STATE.STIMULUS) return;

      const reactionTime = Math.round(performance.now() - stimulusTimestamp);
      reactionHistory.push(reactionTime);
      if (reactionHistory.length > MAX_HISTORY) reactionHistory.shift();

      drawHistoryChart();

      resultEl.textContent = `${reactionTime} ms`;
      instructionsEl.textContent = 'Reaction recorded.';
      transitionTo(STATE.RESULT);
    }

    function handleEarlyInput() {
      clearTimeout(stimulusTimeoutId);
      instructionsEl.textContent = 'Too soon.';
      resultEl.textContent = 'Early input detected';
      transitionTo(STATE.ERROR);
    }

    /* ================================
       INPUT
       ================================ */
    function onUserInput() {
      switch (currentState) {
        case STATE.IDLE:
          startRound();
          break;
        case STATE.WAITING:
          handleEarlyInput();
          break;
        case STATE.STIMULUS:
          handleReaction();
          break;
        case STATE.RESULT:
        case STATE.ERROR:
          transitionTo(STATE.IDLE);
          instructionsEl.textContent = 'Click or press Space to start.';
          break;
      }
    }

    document.addEventListener('click', onUserInput);
    document.addEventListener('keydown', e => {
      if (e.code === 'Space') {
        e.preventDefault();
        onUserInput();
      }
    });

    /* ================================
       CHART WITH GRID, AVG & BEST
       ================================ */
    function drawHistoryChart() {
      const ctx = chartCtx;
      const w = chartCanvas.width;
      const h = chartCanvas.height;

      ctx.clearRect(0, 0, w, h);
      if (reactionHistory.length === 0) return;

      const padding = 30;
      const usableW = w - padding * 2;
      const usableH = h - padding * 2;

      const maxValue = Math.max(...reactionHistory, 300);
      const avg = reactionHistory.reduce((a, b) => a + b, 0) / reactionHistory.length;
      const best = Math.min(...reactionHistory);

      // Grid
      ctx.strokeStyle = '#1F2937';
      ctx.lineWidth = 1;

      for (let i = 0; i <= 5; i++) {
        const y = padding + (i / 5) * usableH;
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(w - padding, y);
        ctx.stroke();
      }

      for (let i = 0; i < MAX_HISTORY; i += 5) {
        const x = padding + (i / (MAX_HISTORY - 1)) * usableW;
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, h - padding);
        ctx.stroke();
      }

      // Average line
      const avgY = padding + usableH - (avg / maxValue) * usableH;
      ctx.strokeStyle = '#FACC15';
      ctx.beginPath();
      ctx.moveTo(padding, avgY);
      ctx.lineTo(w - padding, avgY);
      ctx.stroke();

      // Average label box (LEFT SIDE)
      ctx.fillStyle = '#020617';
      ctx.fillRect(padding + 6, avgY - 12, 100, 18);
      ctx.strokeRect(padding + 6, avgY - 12, 100, 18);
      ctx.fillStyle = '#FACC15';
      ctx.font = '12px JetBrains Mono';
      ctx.fillText(`AVG ${avg.toFixed(0)} ms`, padding + 12, avgY + 2);

      // Reaction line
      ctx.strokeStyle = '#38BDF8';
      ctx.lineWidth = 2;
      ctx.beginPath();

      reactionHistory.forEach((value, i) => {
        const x = padding + (i / (MAX_HISTORY - 1)) * usableW;
        const y = padding + usableH - (value / maxValue) * usableH;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      });

      ctx.stroke();

      // Best value box (TOP RIGHT)
      ctx.fillStyle = '#020617';
      ctx.fillRect(w - padding - 110, padding, 100, 18);
      ctx.strokeRect(w - padding - 110, padding, 100, 18);
      ctx.fillStyle = '#38BDF8';
      ctx.fillText(`BEST ${best} ms`, w - padding - 104, padding + 13);
    }

    /* ================================
       RENDER LOOP
       ================================ */
    function animate() {
      requestAnimationFrame(animate);
      cube.rotation.x += rotationVelocity.x;
      cube.rotation.y += rotationVelocity.y;
      cube.rotation.z += rotationVelocity.z;
      renderer.render(scene, camera);
    }

    /* ================================
       INIT
       ================================ */
    instructionsEl.textContent = 'Click or press Space to start.';
    applyVisualState(STATE.IDLE);
    animate();

    window.addEventListener('resize', () => {
      const { clientWidth, clientHeight } = canvasContainer;
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(clientWidth, clientHeight);
    });
  </script>
</body>
</html>
